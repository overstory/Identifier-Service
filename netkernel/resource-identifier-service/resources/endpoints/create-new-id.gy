import org.netkernel.client.http.representation.HttpClientResponseRepresentation
import org.netkernel.layer0.nkf.INKFAsyncRequestListener
import org.netkernel.layer0.nkf.INKFRequest
import org.netkernel.layer0.nkf.INKFRequestContext
import org.netkernel.layer0.nkf.INKFResponse
import org.netkernel.layer0.nkf.INKFResponseReadOnly
import org.netkernel.layer0.nkf.NKFException

INKFRequestContext context = context

try {
	String templateArg = (context.exists ("arg:template")) ? "?template=${context.source ("arg:template")}" : ''
	String body = (context.exists ("arg:body")) ? context.source ("arg:body", String.class) : ''
	String mimetype = context.source ("arg:mimetype")
	String url = context.source ("arg:url")
	String urlPath = url.replaceFirst ('http://([-a-zA-Z0-9]+)(:[0-9]+)', '')
	String svcPrefix = urlPath.replaceFirst ('/identifier', '')
	String stateId = newHttpState (context)

	req = context.createRequest ("active:httpAsyncPost")
	req.addArgument ("url", context.source ("active:ml/fullurl/identifier${templateArg}", String.class))
	req.addArgument ("config", "res:/config/http-config.xml")
	req.addArgumentByValue ("state", stateId)
	req.addArgumentByValue ("body", body)
	req.setHeader (INKFRequest.HEADER_EXCLUDE_DEPENDENCIES, true);  //We're going to take control of the caching at this level so ignore lower dependencies
	if (mimetype != null) {
		req.addArgumentByValue ("headers", "<hds><Content-Type>${mimetype}</Content-Type></hds>".toString())
	}
	req.setRepresentationClass (HttpClientResponseRepresentation.class);

	//Issue the request asynchronously and release this thread back to do work
	handle = context.issueAsyncRequest (req)

	//Finally set listener and return this thread
	handle.setListener (new CompletedPostListener (svcPrefix, stateId))
	context.setNoResponse()
} catch (e) {
	e.printStackTrace()
	throw e
}

def newHttpState (INKFRequestContext context)
{
	INKFRequest req = context.createRequest ("res:/httpState/newState")

	// Make sure this resource does not depend on the transient HTTP state
	req.setHeader (INKFRequest.HEADER_EXCLUDE_DEPENDENCIES, true);

	return context.issueRequest (req)
}

class CompletedPostListener implements INKFAsyncRequestListener
{
	String svcPrefix
	String stateId

	CompletedPostListener (String svcPrefix, String stateId)
	{
		this.svcPrefix = svcPrefix
		this.stateId = stateId
	}

	def void receiveException (NKFException aException, INKFRequest aRequest, INKFRequestContext context)
	{
		context.delete (stateId)
		context.createResponseFrom (aException);
	}

	static def void copyHeaderToOuter (INKFResponse response, HttpClientResponseRepresentation hcrr, String headerName, String prefix)
	{
		String value = (hcrr.getHeader (headerName) == null) ? "" : hcrr.getHeader (headerName)

		response.setHeader ("httpResponse:/header/${headerName}", "${prefix}${value}".toString())
	}

	static def void copyHeaderToOuter (INKFResponse response, HttpClientResponseRepresentation hcrr, String headerName)
	{
		copyHeaderToOuter (response, hcrr, headerName, "")
	}

	//Receive the client request's response and pass through the relevant pieces.
	def void receiveResponse (INKFResponseReadOnly resp, INKFRequestContext context)
	{
		context.delete (stateId)

		HttpClientResponseRepresentation hcrr = resp.getRepresentation() as HttpClientResponseRepresentation
		def response = context.createResponseFrom (hcrr.getEntity())

		response.setMimeType (hcrr.getHeader ("Content-Type"))
		response.setHeader ("httpResponse:/code", hcrr.getResponseCode())
		copyHeaderToOuter (response, hcrr, "Location", svcPrefix)
		copyHeaderToOuter (response, hcrr, "X-URI")
		copyHeaderToOuter (response, hcrr, "ETag")
		copyHeaderToOuter (response, hcrr, "Content-Type")
		response.setHeader ("httpResponse:/header/Server", "")
	}
}
